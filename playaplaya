#!/usr/bin/python

import pygst
pygst.require("0.10")
import gst
import pygtk
import gtk
import gtk.glade
import gobject
import os
import sys
import time

from conf import Conf

class Main(object):
    MSECS_PER_TICK = 200
    DEFAULT_BOOK_IMAGE_W = 100
    DEFAULT_BOOK_IMAGE_H = 100

    COL_NUM=0
    COL_FILENAME=1

    def _rel_path(self, p):
        return os.path.join(os.path.dirname(__file__), p)

    def __init__(self, app_name, *args, **kwargs):
        super(Main, self).__init__(*args, **kwargs)

        self._conf = Conf(app_name)

        self._current_pos = None
        self._current_duration = None
        self._current_file = None
        self._current_playlist = None

        self._init_gui()
        self._init_gst()
        
        self._conf.load()

        if len(sys.argv) == 2:
            playlist = sys.argv[1]
            self._load_playlist(playlist)
        else:
            self._restore_playlist()

        self._main_win.show()

    def _restore_playlist(self):
        pl = self._conf.get_playlist()
        if pl:
            self._load_playlist(pl)

    def _init_gui(self):
        filename = self._rel_path("gui.glade")

        self._builder = gtk.Builder()
        self._builder.add_from_file(filename)
        self._builder.connect_signals(self)

        self._TIME_FORMAT = gst.Format(gst.FORMAT_TIME)

        self._playliststore = self._builder.get_object('playliststore')
        self._playPauseButton = self._builder.get_object('playPauseButton')

        self._slider = self._builder.get_object('playerHScale')
        self._slider.set_draw_value(False)

        self._bookCoverImage = self._builder.get_object('bookCoverImage')

        self._bookTitleLabel = self._builder.get_object('bookTitleLabel')
        self._chapterLabel = self._builder.get_object('chapterLabel')
        self._miscLabel = self._builder.get_object('miscLabel')

        self._bookTitleLabel.set_label(u"")
        self._chapterLabel.set_label(u"")
        self._miscLabel.set_label(u"")

        # add treeview columns
        treeview = self._builder.get_object('playlistview')
        cell0 = gtk.CellRendererText()
        cell1 = gtk.CellRendererText()
        col0 = gtk.TreeViewColumn("Num", cell0, text=self.__class__.COL_NUM)
        col1 = gtk.TreeViewColumn("Filename", cell1, text=self.__class__.COL_FILENAME)
        treeview.append_column(col0)
        treeview.append_column(col1)

        gobject.timeout_add(self.__class__.MSECS_PER_TICK, self.on_tick)

        img_path = self._rel_path('images/book.png')
        img = self._load_image(img_path, self.__class__.DEFAULT_BOOK_IMAGE_W,self.__class__.DEFAULT_BOOK_IMAGE_H)
        self._bookCoverImage.set_from_pixbuf(img)

        self._main_win = self._builder.get_object('mainwin')

    def _init_gst(self):
        self._player = gst.Pipeline("player")
        source = gst.element_factory_make("filesrc", "file-source")
        decoder = gst.element_factory_make("mad", "mp3-decoder")
        conv = gst.element_factory_make("audioconvert", "converter")
        sink = gst.element_factory_make("alsasink", "alsa-output")

        self._player.add(source, decoder, conv, sink)
        gst.element_link_many(source, decoder, conv, sink)

        bus = self._player.get_bus()
        bus.add_signal_watch()
        bus.connect("message", self.on_message)

    def _load_image(self, fname, w, h):
        pixbuf = gtk.gdk.pixbuf_new_from_file(fname)
        new_pb = pixbuf.scale_simple(w,h,gtk.gdk.INTERP_BILINEAR)
        return new_pb

    def _restore_position_for_playlist(self, playlist, default_file):
        fpath, pos = self._conf.get_pos(playlist, default_file)
        self._play_new_file(fpath)
        print "Loaded pos for %s: %.2f; seeking." % (fpath, pos)
        self._change_slider_and_seek_to(pos)

    def _change_slider_and_seek_to(self, new_pos):
        self._change_slider_pos(new_pos)
        self._seek_to(new_pos)

    def _disable_slider(self):
        try:
            self._slider.handler_block_by_func(self.on_playerHScale_value_changed)
        except TypeError:
            pass

    def _enable_slider(self):
        try:
            self._slider.handler_unblock_by_func(self.on_playerHScale_value_changed)
        except TypeError:
            pass

    def _change_slider_pos(self, new_pos):
        self._disable_slider()
        self._slider.set_range(0.0, self._current_duration)
        self._slider.set_value(new_pos)
        self._enable_slider()

    def _seek_to(self, new_pos):
        self._current_pos = new_pos
        if self._is_playing():
            self._player.seek_simple(self._TIME_FORMAT, gst.SEEK_FLAG_FLUSH, new_pos)
        else:
            self._player.seek_simple(self._TIME_FORMAT, gst.SEEK_FLAG_SKIP, new_pos)

    def _is_playing(self):
        states = self._player.get_state()
        return states[1] == gst.STATE_PLAYING

    def _set_file(self, fpath):
        self._player.get_by_name("file-source").set_property("location", fpath)
        self._current_file = fpath
        self._change_slider_and_seek_to(0.0)

    def _prettify_fpath(self, fpath):
        basename = os.path.basename(fpath)
        basename.replace('_', ' ')
        basename = basename.split('.')[0]
        return basename

    def _play_new_file(self, fpath):
        self._stop()
        self._current_duration = 0.1 # we don't know, but assume this is more than 0, since gtkscale doesn't like it if max == min
        self._set_file(fpath)
        self._chapterLabel.set_label(self._prettify_fpath(fpath))
        self._miscLabel.set_label(u"")
        self._play()

    def _play(self):
        self._player.set_state(gst.STATE_PLAYING)
        self._playPauseButton.set_label("Pause")

    def _pause(self):
        self._player.set_state(gst.STATE_READY)
        self._playPauseButton.set_label("Play")

    def _stop(self):
        self._seek_to(0.0)
        self._player.set_state(gst.STATE_NULL)
        self._current_pos = 0
        self._playPauseButton.set_label("Play")

    def on_book_open_menuitem_activate(self, widget):
        file_chooser = self._builder.get_object('playlistchooserdialog')
        file_chooser.show()

    def _install_playlist_lines(self, lines):
        playliststore = self._builder.get_object("playliststore")
        playliststore.clear()
        count = 1
        for l in lines:
            playliststore.append([count, l])
            count += 1

    def _load_playlist(self, fpath):
        fp = open(fpath, 'r')
        lines = fp.readlines()
        lines = [ l.strip() for l in lines ]
        lines = [ l for l in lines if not l.startswith('#') ]
        fp.close()
        fp = None

        self._current_playlist = fpath
        name = self._prettify_fpath(fpath)
        self._bookTitleLabel.set_label(name)

        if lines is not None:
            self._install_playlist_lines(lines)

        self._restore_position_for_playlist(self._current_playlist, lines[0])

    def on_playlistchooserdialog_file_activated(self, filedialog):
        filedialog.hide()
        self._load_playlist(filedialog.get_filename())

    def on_playlistview_cursor_changed(self, widget):
        path, col = widget.get_cursor()
        it = self._playliststore.get_iter(path)
        filepath = self._playliststore.get_value(it, 1)
        self._play_new_file(filepath)

    def _clear_current_file(self):
        self._chapterLabel.set_label(u"")
        self._miscLabel.set_label(u"")
        self._slider.set_range(0.0, 0.1)
        self._slider.set_value(0.0)

    def _next_file(self):
        self._clear_current_file()
    
        current_file = self._current_file
        num_items = len(self._playliststore)

        current_idx = None
        for idx, item in enumerate(self._playliststore):
            if item[1] == current_file:
                current_idx = idx

        next_file = None
        if current_idx is not None:
            next_idx = current_idx+1
            if next_idx < num_items:
                next_item = self._playliststore[next_idx]
                next_file = next_item[1]

        if next_file:
            print "Attempting to play %r" % next_file
            self._play_new_file(next_file)
        else:
            self._stop()

    def on_message(self, bus, message):
        t = message.type

        if t == gst.MESSAGE_EOS:
            self._next_file()
        elif t == gst.MESSAGE_ERROR:
            self._stop()
            err, debug = message.parse_error()
            print "Error: %s" % err, debug

    def on_tick(self):
        if self._is_playing():
            try:
                self._current_duration = float(self._player.query_duration(self._TIME_FORMAT)[0])
                self._current_pos = self._player.query_position(self._TIME_FORMAT)[0]
                self._change_slider_pos(self._current_pos)
            except gst.QueryError:
                pass

        return True

    def on_playerHScale_value_changed(self, widget):
        val = widget.get_value()
        self._seek_to(val)

    def on_playPauseButton_clicked(self, widget):
        if self._is_playing():
            self._pause()
        else:
            self._play()

    def on_previousButton_clicked(self, widget):
        pass

    def on_backButton_clicked(self, widget):
        pass

    def on_forwardButton_clicked(self, widget):
        pass

    def on_nextButton_clicked(self, widget):
        self._next_file()

    def _quit(self):
        if self._current_playlist and self._current_file:
            self._conf.set_playlist(self._current_playlist)
            self._conf.set_pos(self._current_playlist, self._current_file, self._current_pos)
        self._conf.save()
        gtk.main_quit()

    def on_mainwin_destroy(self, widget):
        self._quit()

    def on_app_quit_menuitem_activate(self, widget):
        self._quit()

main = Main("PlayaPlaya")
gtk.gdk.threads_init()
gtk.main()

